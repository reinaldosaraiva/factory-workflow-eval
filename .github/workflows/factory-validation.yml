name: factory-validation

on:
  issues:
    types: [opened, edited, reopened, labeled]
  pull_request:
    types: [opened, edited, synchronize, reopened, labeled]
  workflow_dispatch:

jobs:
  validate_issue_contract:
    if: github.event_name == 'issues' && contains(toJson(github.event.issue.labels), 'factory')
    runs-on: ubuntu-latest
    steps:
      - name: Validate issue sections
        env:
          ISSUE_BODY: ${{ github.event.issue.body }}
        run: |
          required_sections=(
            "## User Story"
            "## Acceptance Criteria"
            "## Gherkin Scenarios"
            "## Technical Scope"
            "## Out of Scope"
            "## Evidence Checklist"
          )
          for section in "${required_sections[@]}"; do
            echo "$ISSUE_BODY" | grep -q "$section" || {
              echo "Missing required section: $section"
              exit 1
            }
          done
          echo "Issue contract validated."

  validate_pr_contract:
    if: github.event_name == 'pull_request' && contains(toJson(github.event.pull_request.labels), 'factory')
    runs-on: ubuntu-latest
    steps:
      - name: Validate PR title convention
        env:
          PR_TITLE: ${{ github.event.pull_request.title }}
        run: |
          echo "$PR_TITLE" | grep -Eq '^(feat|fix|refactor|chore|docs|test|ci|perf)(\(.+\))?: .+' || {
            echo "PR title does not follow conventional commits."
            exit 1
          }
          echo "PR title convention validated."

      - name: Validate PR body evidence sections
        env:
          PR_BODY: ${{ github.event.pull_request.body }}
        run: |
          required_sections=(
            "## Changes"
            "## Tests"
            "## Acceptance Criteria"
            "## Risks"
            "## Risk Matrix"
            "## Traceability"
            "## Agent Plan"
            "## Execution Evidence"
            "## Evidence Records"
            "## Evidence"
          )
          for section in "${required_sections[@]}"; do
            echo "$PR_BODY" | grep -q "$section" || {
              echo "Missing required PR section: $section"
              exit 1
            }
          done

          execution_block="$(echo "$PR_BODY" | awk '
            /^## Execution Evidence/ {capture=1; next}
            /^## / && capture==1 {exit}
            capture==1 {print}
          ')"

          echo "$execution_block" | grep -Eq '^- Command: .+' || {
            echo "Execution evidence must include at least one '- Command: ...' line."
            exit 1
          }

          echo "$execution_block" | grep -Eq '^- Result: .+' || {
            echo "Execution evidence must include at least one '- Result: ...' line."
            exit 1
          }

          traceability_block="$(echo "$PR_BODY" | awk '
            /^## Traceability/ {capture=1; next}
            /^## / && capture==1 {exit}
            capture==1 {print}
          ')"

          echo "$traceability_block" | grep -Eq 'Issue URL:\s*https://github\.com/.+/issues/[0-9]+' || {
            echo "Traceability section must include a valid Issue URL."
            exit 1
          }

          echo "$traceability_block" | grep -Eq 'PR URL:\s*https://github\.com/.+/pull/[0-9]+' || {
            echo "Traceability section must include a valid PR URL."
            exit 1
          }

          echo "$traceability_block" | grep -Eq 'Run URL:\s*https://github\.com/.+/actions/runs/[0-9]+' || {
            echo "Traceability section must include a valid CI Run URL."
            exit 1
          }

          agent_plan_block="$(echo "$PR_BODY" | awk '
            /^## Agent Plan/ {capture=1; next}
            /^## / && capture==1 {exit}
            capture==1 {print}
          ')"

          echo "$agent_plan_block" | grep -Eq 'AGENT_BACKEND_STATUS:\s*(PLANNED|N/A|DONE)$' || {
            echo "Agent Plan must include AGENT_BACKEND_STATUS with value PLANNED|N/A|DONE."
            exit 1
          }

          echo "$agent_plan_block" | grep -Eq 'AGENT_FRONTEND_STATUS:\s*(PLANNED|N/A|DONE)$' || {
            echo "Agent Plan must include AGENT_FRONTEND_STATUS with value PLANNED|N/A|DONE."
            exit 1
          }

          echo "$agent_plan_block" | grep -Eq 'AGENT_QA_STATUS:\s*(PLANNED|N/A|DONE)$' || {
            echo "Agent Plan must include AGENT_QA_STATUS with value PLANNED|N/A|DONE."
            exit 1
          }

          backend_status="$(echo "$agent_plan_block" | sed -nE 's/^- AGENT_BACKEND_STATUS:\s*(PLANNED|N\/A|DONE)$/\1/p' | head -n 1)"
          frontend_status="$(echo "$agent_plan_block" | sed -nE 's/^- AGENT_FRONTEND_STATUS:\s*(PLANNED|N\/A|DONE)$/\1/p' | head -n 1)"
          qa_status="$(echo "$agent_plan_block" | sed -nE 's/^- AGENT_QA_STATUS:\s*(PLANNED|N\/A|DONE)$/\1/p' | head -n 1)"

          if [ "$backend_status" = "N/A" ]; then
            backend_justification="$(echo "$agent_plan_block" | sed -nE 's/^- AGENT_BACKEND_JUSTIFICATION:\s*(.+)$/\1/p' | head -n 1)"
            [ -z "$backend_justification" ] && {
              echo "Agent Plan requires AGENT_BACKEND_JUSTIFICATION when AGENT_BACKEND_STATUS is N/A."
              exit 1
            }
            echo "$backend_justification" | grep -Eqi '^(n/a|na|none|-)$' && {
              echo "AGENT_BACKEND_JUSTIFICATION cannot be a placeholder value."
              exit 1
            }
            [ "$(echo "$backend_justification" | tr -d '[:space:]' | wc -c | tr -d ' ')" -lt 15 ] && {
              echo "AGENT_BACKEND_JUSTIFICATION must contain at least 15 non-space characters."
              exit 1
            }
            echo "$backend_justification" | grep -Eqi '(backend|api|scope|escopo|teste|test)' || {
              echo "AGENT_BACKEND_JUSTIFICATION must mention backend/API/scope context."
              exit 1
            }
          fi

          if [ "$frontend_status" = "N/A" ]; then
            frontend_justification="$(echo "$agent_plan_block" | sed -nE 's/^- AGENT_FRONTEND_JUSTIFICATION:\s*(.+)$/\1/p' | head -n 1)"
            [ -z "$frontend_justification" ] && {
              echo "Agent Plan requires AGENT_FRONTEND_JUSTIFICATION when AGENT_FRONTEND_STATUS is N/A."
              exit 1
            }
            echo "$frontend_justification" | grep -Eqi '^(n/a|na|none|-)$' && {
              echo "AGENT_FRONTEND_JUSTIFICATION cannot be a placeholder value."
              exit 1
            }
            [ "$(echo "$frontend_justification" | tr -d '[:space:]' | wc -c | tr -d ' ')" -lt 15 ] && {
              echo "AGENT_FRONTEND_JUSTIFICATION must contain at least 15 non-space characters."
              exit 1
            }
            echo "$frontend_justification" | grep -Eqi '(frontend|web|scope|escopo|teste|test)' || {
              echo "AGENT_FRONTEND_JUSTIFICATION must mention frontend/web/scope context."
              exit 1
            }
          fi

          if [ "$qa_status" = "N/A" ]; then
            qa_justification="$(echo "$agent_plan_block" | sed -nE 's/^- AGENT_QA_JUSTIFICATION:\s*(.+)$/\1/p' | head -n 1)"
            [ -z "$qa_justification" ] && {
              echo "Agent Plan requires AGENT_QA_JUSTIFICATION when AGENT_QA_STATUS is N/A."
              exit 1
            }
            echo "$qa_justification" | grep -Eqi '^(n/a|na|none|-)$' && {
              echo "AGENT_QA_JUSTIFICATION cannot be a placeholder value."
              exit 1
            }
            [ "$(echo "$qa_justification" | tr -d '[:space:]' | wc -c | tr -d ' ')" -lt 15 ] && {
              echo "AGENT_QA_JUSTIFICATION must contain at least 15 non-space characters."
              exit 1
            }
            echo "$qa_justification" | grep -Eqi '(qa|quality|teste|test|scope|escopo)' || {
              echo "AGENT_QA_JUSTIFICATION must mention QA/test/scope context."
              exit 1
            }
          fi

          records_block="$(echo "$PR_BODY" | awk '
            /^## Evidence Records/ {capture=1; next}
            /^## / && capture==1 {exit}
            capture==1 {print}
          ')"

          echo "$records_block" | grep -Eq '^- EVIDENCE_SCHEMA_VERSION:\s*v1$' || {
            echo "Evidence Records must include '- EVIDENCE_SCHEMA_VERSION: v1'."
            exit 1
          }

          echo "$records_block" | grep -Eq '^- EVIDENCE_COMMAND_1:\s*.+$' || {
            echo "Evidence Records must include '- EVIDENCE_COMMAND_1: ...'."
            exit 1
          }

          echo "$records_block" | grep -Eq '^- EVIDENCE_RESULT_1:\s*.+$' || {
            echo "Evidence Records must include '- EVIDENCE_RESULT_1: ...'."
            exit 1
          }

          echo "$records_block" | grep -Eq '^- EVIDENCE_ARTIFACT_1:\s*.+$' || {
            echo "Evidence Records must include '- EVIDENCE_ARTIFACT_1: ...'."
            exit 1
          }

          record_indexes="$(
            echo "$records_block" \
              | sed -nE 's/^- EVIDENCE_(COMMAND|RESULT|ARTIFACT)_([0-9]+):.*/\2/p' \
              | sort -n \
              | uniq
          )"

          records_count="$(echo "$record_indexes" | grep -Ec '^[0-9]+$' || true)"
          if [ "$records_count" -lt 2 ]; then
            echo "Evidence Records must include at least two indexed records (_1 and _2)."
            exit 1
          fi

          expected_index=1
          while IFS= read -r idx; do
            [ -z "$idx" ] && continue
            if [ "$idx" -ne "$expected_index" ]; then
              echo "Evidence Records indexes must be sequential without gaps (expected _${expected_index}, got _${idx})."
              exit 1
            fi

            echo "$records_block" | grep -Eq "^- EVIDENCE_COMMAND_${idx}:\\s*.+$" || {
              echo "Evidence Records missing '- EVIDENCE_COMMAND_${idx}: ...'."
              exit 1
            }
            echo "$records_block" | grep -Eq "^- EVIDENCE_RESULT_${idx}:\\s*.+$" || {
              echo "Evidence Records missing '- EVIDENCE_RESULT_${idx}: ...'."
              exit 1
            }
            echo "$records_block" | grep -Eq "^- EVIDENCE_ARTIFACT_${idx}:\\s*.+$" || {
              echo "Evidence Records missing '- EVIDENCE_ARTIFACT_${idx}: ...'."
              exit 1
            }

            artifact_value="$(
              echo "$records_block" | sed -nE "s/^- EVIDENCE_ARTIFACT_${idx}:\\s*(.+)$/\\1/p" | head -n 1
            )"
            result_value="$(
              echo "$records_block" | sed -nE "s/^- EVIDENCE_RESULT_${idx}:\\s*(.+)$/\\1/p" | head -n 1
            )"
            echo "$result_value" | grep -Eq '^(PASS|FAIL|WARN|SKIP)(\s*\(.+\))?$' || {
              echo "Evidence Records EVIDENCE_RESULT_${idx} must use status PASS|FAIL|WARN|SKIP, optionally with details in parentheses."
              exit 1
            }

            if echo "$result_value" | grep -Eq '^(FAIL|WARN)(\s*\(.+\))?$'; then
              echo "$artifact_value" | grep -Eqi '^(local-terminal-output|none|n/a|na)$' && {
                echo "Evidence Records EVIDENCE_ARTIFACT_${idx} must be a concrete artifact when EVIDENCE_RESULT_${idx} is FAIL or WARN."
                exit 1
              }

              echo "$artifact_value" | grep -Eq '^(https?://.+|[A-Za-z0-9._/-]+\.[A-Za-z0-9]{1,10})$' || {
                echo "Evidence Records EVIDENCE_ARTIFACT_${idx} must be a URL (http/https) or a file path with extension when EVIDENCE_RESULT_${idx} is FAIL or WARN."
                exit 1
              }
            fi

            expected_index=$((expected_index + 1))
          done <<< "$record_indexes"

          duplicate_commands="$(
            echo "$records_block" \
              | sed -nE 's/^- EVIDENCE_COMMAND_[0-9]+:\s*(.+)$/\1/p' \
              | sort \
              | uniq -d
          )"
          [ -n "$duplicate_commands" ] && {
            echo "Evidence Records must not contain duplicated EVIDENCE_COMMAND_n values."
            echo "Duplicated commands:"
            echo "$duplicate_commands"
            exit 1
          }

          duplicate_artifacts="$(
            echo "$records_block" \
              | sed -nE 's/^- EVIDENCE_ARTIFACT_[0-9]+:\s*(.+)$/\1/p' \
              | sort \
              | uniq -d
          )"
          [ -n "$duplicate_artifacts" ] && {
            echo "Evidence Records must not contain duplicated EVIDENCE_ARTIFACT_n values."
            echo "Duplicated artifacts:"
            echo "$duplicate_artifacts"
            exit 1
          }

          echo "PR evidence contract validated."

  validate_model_policy:
    if: github.event_name == 'pull_request' && contains(toJson(github.event.pull_request.labels), 'factory')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Enforce model policy (block gemini-2.5)
        run: |
          mapfile -t candidates < <(
            while IFS= read -r file; do
              if jq -e '.graph.nodes' "$file" >/dev/null 2>&1; then
                echo "$file"
              fi
            done < <(find . -type f -name "*.json")
          )

          if [ "${#candidates[@]}" -eq 0 ]; then
            echo "No workflow draft JSON files found in repo. Skipping model-policy file checks."
            exit 0
          fi

          failed=0
          for file in "${candidates[@]}"; do
            echo "Checking workflow draft file: $file"
            if ! scripts/factory/validate_no_gemini25_in_draft.sh --draft-file "$file"; then
              failed=1
            fi
          done

          if [ "$failed" -ne 0 ]; then
            echo "Model policy validation failed."
            exit 1
          fi

          echo "Model policy validation passed."

  validate_quality_security:
    if: github.event_name == 'pull_request' && contains(toJson(github.event.pull_request.labels), 'factory')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Run quality and security baseline checks
        run: |
          chmod +x scripts/quality/run_quality_security_checks.sh
          chmod +x scripts/quality/scan_for_secrets.sh
          scripts/quality/run_quality_security_checks.sh

  validate_coverage:
    if: github.event_name == 'pull_request' && contains(toJson(github.event.pull_request.labels), 'factory')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install coverage dependency
        run: python3 -m pip install --disable-pip-version-check coverage

      - name: Run coverage gate
        run: |
          chmod +x scripts/quality/run_coverage_gate.sh
          scripts/quality/run_coverage_gate.sh 70

  agent_backend:
    if: github.event_name == 'pull_request' && contains(toJson(github.event.pull_request.labels), 'factory')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Execute backend agent
        env:
          PR_BODY: ${{ github.event.pull_request.body }}
        run: |
          agent_plan_block="$(echo "$PR_BODY" | awk '
            /^## Agent Plan/ {capture=1; next}
            /^## / && capture==1 {exit}
            capture==1 {print}
          ')"

          backend_status="$(echo "$agent_plan_block" | sed -nE 's/^- AGENT_BACKEND_STATUS:\s*(PLANNED|N\/A|DONE)$/\1/p' | head -n 1)"
          [ -z "$backend_status" ] && {
            echo "AGENT_BACKEND_STATUS not found in Agent Plan."
            exit 1
          }

          echo "Backend agent status: $backend_status"
          if [ "$backend_status" = "N/A" ]; then
            echo "Backend agent skipped by plan."
            exit 0
          fi

          chmod +x scripts/quality/run_quality_security_checks.sh scripts/quality/scan_for_secrets.sh
          scripts/quality/run_quality_security_checks.sh
          echo "Backend agent execution completed."

  agent_frontend:
    if: github.event_name == 'pull_request' && contains(toJson(github.event.pull_request.labels), 'factory')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Execute frontend agent
        env:
          PR_BODY: ${{ github.event.pull_request.body }}
        run: |
          agent_plan_block="$(echo "$PR_BODY" | awk '
            /^## Agent Plan/ {capture=1; next}
            /^## / && capture==1 {exit}
            capture==1 {print}
          ')"

          frontend_status="$(echo "$agent_plan_block" | sed -nE 's/^- AGENT_FRONTEND_STATUS:\s*(PLANNED|N\/A|DONE)$/\1/p' | head -n 1)"
          [ -z "$frontend_status" ] && {
            echo "AGENT_FRONTEND_STATUS not found in Agent Plan."
            exit 1
          }

          echo "Frontend agent status: $frontend_status"
          if [ "$frontend_status" = "N/A" ]; then
            echo "Frontend agent skipped by plan."
            exit 0
          fi

          # Pilot repository has no frontend source tree; keep an explicit execution marker.
          if [ -d web ]; then
            echo "Frontend source detected."
          else
            echo "Frontend source not present in pilot repository; running frontend agent in pilot mode."
          fi
          echo "Frontend agent execution completed."

  agent_qa:
    if: github.event_name == 'pull_request' && contains(toJson(github.event.pull_request.labels), 'factory')
    runs-on: ubuntu-latest
    needs:
      - validate_pr_contract
      - validate_model_policy
      - validate_quality_security
      - validate_coverage
      - agent_backend
      - agent_frontend
    steps:
      - name: Execute QA agent
        env:
          PR_BODY: ${{ github.event.pull_request.body }}
          BACKEND_RESULT: ${{ needs.agent_backend.result }}
          FRONTEND_RESULT: ${{ needs.agent_frontend.result }}
          CONTRACT_RESULT: ${{ needs.validate_pr_contract.result }}
          POLICY_RESULT: ${{ needs.validate_model_policy.result }}
          QUALITY_RESULT: ${{ needs.validate_quality_security.result }}
          COVERAGE_RESULT: ${{ needs.validate_coverage.result }}
        run: |
          agent_plan_block="$(echo "$PR_BODY" | awk '
            /^## Agent Plan/ {capture=1; next}
            /^## / && capture==1 {exit}
            capture==1 {print}
          ')"

          qa_status="$(echo "$agent_plan_block" | sed -nE 's/^- AGENT_QA_STATUS:\s*(PLANNED|N\/A|DONE)$/\1/p' | head -n 1)"
          [ -z "$qa_status" ] && {
            echo "AGENT_QA_STATUS not found in Agent Plan."
            exit 1
          }

          echo "QA agent status: $qa_status"
          if [ "$qa_status" = "N/A" ]; then
            echo "QA agent skipped by plan."
            exit 0
          fi

          for result in \
            "$BACKEND_RESULT" \
            "$FRONTEND_RESULT" \
            "$CONTRACT_RESULT" \
            "$POLICY_RESULT" \
            "$QUALITY_RESULT" \
            "$COVERAGE_RESULT"; do
            if [ "$result" != "success" ]; then
              echo "QA gate failed: prerequisite job result is '$result'."
              exit 1
            fi
          done

          echo "QA agent execution completed. All prerequisite gates are successful."
